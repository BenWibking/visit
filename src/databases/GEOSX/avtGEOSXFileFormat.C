// Copyright (c) Lawrence Livermore National Security, LLC and other VisIt
// Project developers.  See the top-level LICENSE file for dates and other
// details.  No copyright assignment is required to contribute to VisIt.

// ****************************************************************************
//  avtGEOSXFileFormat.C
// ****************************************************************************

#include <avtGEOSXFileFormat.h>
#include <GEOSXParser.h>

#include <avtDatabaseMetaData.h>
#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include <InvalidVariableException.h>
#include <InvalidFilesException.h>

#include <vtkCellData.h>
#include <vtkDataArray.h>
#include <vtkDataSet.h>
#include <vtkDataSetReader.h>
#include <vtkImageData.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkXMLImageDataReader.h>
#include <vtkXMLPolyDataReader.h>
#include <vtkXMLRectilinearGridReader.h>
#include <vtkXMLStructuredGridReader.h>
#include <vtkXMLUnstructuredGridReader.h>

using std::map;
using std::set;
using std::string;
using std::vector;


// ****************************************************************************
//  Method: avtGEOSXFileFormat constructor
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

avtGEOSXFileFormat::avtGEOSXFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1), metaFile(filename)
{
    parser = nullptr; 
    haveReadMetaFile = false;
}


// ****************************************************************************
//  Method: avtGEOSXFileFormat::ReadInMetaFile
//
//  Purpose:
//      Reads the .vtm file
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

void
avtGEOSXFileFormat::ReadMetaFile()
{
    if(parser)
    {
        delete parser;
    }
    parser = new GEOSXParser;
    parser->SetFileName(metaFile);
    if (!parser->Parse())
    {
        string em = parser->GetErrorMessage();
        delete parser;
        parser = nullptr;
        EXCEPTION2(InvalidFilesException, metaFile, em);
        return;
    }
    int nDataSets = parser->GetNumberOfDataSets();
    datasets.resize(nDataSets);
    for(int i = 0; i < nDataSets; ++i)
    {
        datasets[i] = nullptr;
    }
    haveReadMetaFile = true;
}

void
avtGEOSXFileFormat::ReadDataSet(const string &meshName, const int blockNum, const int idx)
{
    string blockFileName = parser->GetBlockFileName(meshName, blockNum);
cerr << "  reading from file : " << blockFileName << endl;
   
    size_t pos = blockFileName.find_last_of(".");
    string ext;
    if(pos != string::npos)
        ext = blockFileName.substr(pos); 
    
    //
    // This shouldn't ever happen (since we would already have the dataset
    // we are trying to read from the file sitting in memory), but anything
    // to prevent leaks.
    //
    if (datasets[idx] != nullptr)
    {
        datasets[idx]->Delete();
        datasets[idx] = nullptr;
    }

    vtkDataSet *dataset = nullptr;

    if (ext.empty() || ext == ".vtk")
    {
        if (ext.empty())
        {
            debug1 << "No extension given ... assuming legacy VTK format."
                   << endl;
        }

        //
        // Create a file reader and set our dataset to be its output.
        //
        vtkDataSetReader *reader = vtkDataSetReader::New();
        reader->ReadAllScalarsOn();
        reader->ReadAllVectorsOn();
        reader->ReadAllTensorsOn();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName); 
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else if (ext == ".vti")
    {
        vtkXMLImageDataReader *reader = vtkXMLImageDataReader::New();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName);
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else if (ext == ".vtr")
    {
        vtkXMLRectilinearGridReader *reader =
            vtkXMLRectilinearGridReader::New();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName);
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else if (ext == ".vts")
    {
        vtkXMLStructuredGridReader *reader =
            vtkXMLStructuredGridReader::New();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName);
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else if (ext == ".vtp")
    {
        vtkXMLPolyDataReader *reader = vtkXMLPolyDataReader::New();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName);
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else if (ext == ".vtu")
    {
        vtkXMLUnstructuredGridReader *reader =
            vtkXMLUnstructuredGridReader::New();
        reader->SetFileName(blockFileName.c_str());
        reader->Update();
        dataset = reader->GetOutput();
        if (dataset == nullptr)
        {
            EXCEPTION1(InvalidFilesException, blockFileName);
        }
        dataset->Register(nullptr);
        reader->Delete();
    }
    else
    {
        EXCEPTION2(InvalidFilesException, blockFileName, 
                   "could not match extension to a VTK file format type");
    }

    // Shoulde we read TIME and CYCLE from this dataset?

    // IS THE FOLLOWING NECESSARY?

    // Convert vtkGhostType to avtGhostDataType
    // Rename the arrays stored in dataset->GetCellData()
    // and dataset->GetPointData()

    vtkDataArray *zoneArray = dataset->GetCellData()->GetArray("vtkGhostType");
    if (zoneArray)
    {
        zoneArray->SetName("avtGhostZones");
        dataset->GetCellData()->AddArray(zoneArray);
    }

    vtkDataArray *nodeArray = dataset->GetPointData()->GetArray("vtkGhostType");
    if (nodeArray)
    {
        nodeArray->SetName("avtGhostNodes");
        dataset->GetPointData()->AddArray(nodeArray);
    }

    datasets[idx] = dataset;
}



// ****************************************************************************
//  Method: avtGEOSXFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************


namespace GEOSXFF
{
    // nodal var names associated with each mesh
    map<string, set<string>> meshVarsNodal;
    // zonal var names associated with each mesh
    map<string, set<string>> meshVarsZonal;
    // vars that occur in both nodal and zonal lists
    map<string, vector<string>> meshVarsDuplicate;
    map<string, int> varComponents;

    void
    FreeUpResources()
    {
        meshVarsNodal.clear();
        meshVarsZonal.clear();
        meshVarsDuplicate.clear();
        varComponents.clear();
    }

    void
    ReadVars(vtkDataSetAttributes *atts, bool zoneCentered,
             const string &meshName)
    {
        for(int i = 0; i < atts->GetNumberOfArrays(); ++i)
        {
            vtkDataArray *arr = atts->GetArray(i);
            string varName(arr->GetName());
            if(zoneCentered)
                meshVarsZonal[meshName].insert(varName);
            else
                meshVarsNodal[meshName].insert(varName);
            varComponents[varName] = arr->GetNumberOfComponents();
        }
    }


    void
    ReadVars(vtkDataSet *ds, const string &meshName)
    {
        ReadVars(ds->GetPointData(), false, meshName);
        ReadVars(ds->GetCellData(), true, meshName);
    }

    void
    ComputeDuplicateVars(const string &meshName)
    {
        set<string> nodeVars = meshVarsNodal[meshName];
        set<string> cellVars = meshVarsZonal[meshName];
        // determine if there are vars duplicated in nodeVars and cellVars.
        // Will need to change the names to var_nodal and var_zonal 

        vector<string> var_intersection;
        std::set_intersection(nodeVars.begin(), nodeVars.end(),
                              cellVars.begin(), cellVars.end(),
                              std::back_inserter(var_intersection));

        meshVarsDuplicate[meshName] = var_intersection;
    }


    void
    GetListOfUniqueCellTypes(vtkUnstructuredGrid *ug, vtkUnsignedCharArray *uca)
    {
        bool   haveCellType[256];
        for (int i = 0 ; i < 256 ; i++)
            haveCellType[i] = false;

        int ncells = ug->GetNumberOfCells();
        for (int i = 0 ; i < ncells ; i++)
            haveCellType[ug->GetCellType(i)] = true;

        int ntypes = 0;
        for (int i = 0 ; i < 256 ; i++)
            if (haveCellType[i])
                ntypes++;

        uca->SetNumberOfTuples(ntypes);
        int idx = 0;
        for (int i = 0 ; i < 256 ; i++)
            if (haveCellType[i])
                uca->SetValue(idx++, i);
    }

    // Borrowed heavily from avtVTKFileReader::PopulateDatabaseMetaData
    void
    AddVars(const string &meshName, const set<string> &vars, avtCentering center, avtDatabaseMetaData *md)
    {
        vector<string> dups = meshVarsDuplicate[meshName];
        for (auto v : vars)
        {
            int ncomp = varComponents[v];
            string varName = meshName + string("/") + v;
            if (std::find(dups.begin(), dups.end(), v) != dups.end())
            {
                if(center == AVT_NODECENT)
                    varName += "_nodal";
                else
                    varName += "_zonal";
            }
            if (ncomp == 1)
            {
                avtScalarMetaData *scalar = new avtScalarMetaData();
                scalar->name = varName;
                scalar->meshName = meshName;
                scalar->centering = center;
                md->Add(scalar);
            }
            else if (ncomp <= 4)
            {
                avtVectorMetaData *vector = new avtVectorMetaData();
                vector->name = varName;
                vector->meshName = meshName;
                vector->centering = center;
                vector->varDim = ncomp;
                md->Add(vector);
            }
            else if (ncomp == 9)
            {
                avtTensorMetaData *tensor = new avtTensorMetaData();
                tensor->name = varName;
                tensor->meshName = meshName;
                tensor->centering = center;
                tensor->dim = ncomp;
                md->Add(tensor);
            }
            else
            {
                // add the array meta data
                avtArrayMetaData *array = new avtArrayMetaData();
                array->name = varName;
                array->nVars = ncomp;
                array->compNames.resize(ncomp);
                for (int i = 0 ; i < ncomp ; i++)
                {
                    char name[16];
                    snprintf(name, 16, "comp%02d", i);
                    array->compNames[i] = name;
                }
                array->meshName = meshName;
                array->centering = center;

                md->Add(array);

                // create array_decompose expressions
                // if ncomp > 10 need to do _01, _02 etc
                // if ncomp > 100 need to do _001, _002 etc
                // how to %format with to_string?
#if 0
                for(int c = 0; c < ncomp; ++c)
                {
                    string cs = std::to_string(c);
                    string en = varName + string("/comp_") + cs;
                    string ed = string("array_decompose(<") + varName +
                                string(">, ") + cs + string(")");
                    Expression e;
                    e.SetType(Expression::ScalarMeshVar);
                    e.SetName(en);
                    e.SetDefinition(ed);
                    md->AddExpression(&e);
                }
#endif

                int compnamelen = int(varName.size()) + 40;
                char *exp_name = new char[compnamelen];
                char *exp_def = new char[compnamelen];
                char *cs = new char[compnamelen];
                string fmt = "%d";
                if(ncomp > 100)
                    fmt = "%02d";
                else if (ncomp > 10) 
                    fmt = "%0d";
                for(int c = 0; c < ncomp; ++c)
                {
                    snprintf(cs, compnamelen, fmt.c_str(), c);
                    snprintf(exp_name, compnamelen, "%s/comp_%s",
                             varName.c_str(), cs);
                    snprintf(exp_def,  compnamelen, "array_decompose(<%s>, %s)",
                             varName.c_str(), cs);
                    Expression e;
                    e.SetType(Expression::ScalarMeshVar);
                    e.SetName(exp_name);
                    e.SetDefinition(exp_def);
                    md->AddExpression(&e);
                }
                delete [] exp_name;
                delete [] exp_def;

            }
        }
    }

    void
    FillMetaData(vtkDataSet *ds, const string &meshName,
                 avtDatabaseMetaData *md, 
                 const vector<string> &groupNames,
                 const vector<int> &groupIds,
                 const vector<string> &blockNames)
    {
        int spat = 3;
        int topo = 3;

        avtMeshType type;
        int  vtkType = ds->GetDataObjectType();
        switch (vtkType)
        {
          case VTK_RECTILINEAR_GRID:
            type = AVT_RECTILINEAR_MESH;
            break;
          case VTK_STRUCTURED_GRID:
            type = AVT_CURVILINEAR_MESH;
            break;
          case VTK_UNSTRUCTURED_GRID:
            type = AVT_UNSTRUCTURED_MESH;
            break;
          case VTK_POLY_DATA:
            topo = 2;
            type = AVT_SURFACE_MESH;
            break;
          default:
            debug1 << "Unable to identify mesh type " << vtkType << endl;
            type = AVT_UNKNOWN_MESH;
            break;
        }

        double bounds[6];
        ds->GetBounds(bounds);

        if ((bounds[4] == bounds[5]) && (bounds[5] == 0.))
        {
            spat = 2;
            topo = 2;
        }

        //
        // Some mesh types can have a lower topological dimension
        //
        if (vtkType == VTK_UNSTRUCTURED_GRID)
        {
            vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::SafeDownCast(ds);

            if(ugrid->GetNumberOfPoints() > 0)
            {
                if (ugrid->GetNumberOfCells() == 0)
                {
                    // no cells declared, assume  point mesh.
                    debug5 << "The GEOSX file contains all points -- "
                           << "declaring this a point mesh." << endl;
                    type = AVT_POINT_MESH;
                    topo = 0;
                }
                else
                {
                    vtkUnsignedCharArray *types = vtkUnsignedCharArray::New();
                    GetListOfUniqueCellTypes(ugrid, types);

                    if (types->GetNumberOfTuples() == 1)
                    {
                        int myType = (int) types->GetValue(0);
                        if (myType == VTK_VERTEX)
                        {
                            debug5 << "The GEOSX file contains all points -- "
                               << "declaring this a point mesh." << endl;
                            type = AVT_POINT_MESH;
                            topo = 0;
                        }
                        else if(myType == VTK_LINE)
                        {
                            debug5 << "The mesh contains all lines, set topo=1" << endl;
                            topo = 1;
                        }
                    }
                    types->Delete();
                }
            }
        }
        else if (vtkType == VTK_STRUCTURED_GRID)
        {
            vtkStructuredGrid *sgrid = vtkStructuredGrid::SafeDownCast(ds);
            int dims[3];
            sgrid->GetDimensions(dims);
            if ((dims[0] == 1 && dims[1] == 1) ||
                (dims[0] == 1 && dims[2] == 1) ||
                (dims[1] == 1 && dims[2] == 1))
            {
                topo = 1;
            }
            else if (dims[0] == 1 || dims[1] == 1 || dims[2] == 1)
            {
                topo = 2;
            }
        }
        else if (vtkType == VTK_POLY_DATA)
        {
            vtkPolyData *pd = vtkPolyData::SafeDownCast(ds);
            if (pd->GetNumberOfPoints() > 0)
            {
                if (pd->GetNumberOfPolys() == 0 && pd->GetNumberOfStrips() == 0)
                {
                    if (pd->GetNumberOfLines() > 0)
                    {
                        topo = 1;
                    }
                    else
                    {
                        debug3 << "The GEOSX file contains all points -- "
                               << "declaring this a point mesh." << endl;
                        type = AVT_POINT_MESH;
                        topo = 0;
                    }
                }
            }
        }
    
        avtMeshMetaData *mesh = new avtMeshMetaData;
        mesh->name = meshName;
        mesh->meshType = type;
        mesh->spatialDimension = spat;
        mesh->topologicalDimension = topo;
        mesh->numGroups = groupNames.size();
        if(groupIds.size() > 0)
            mesh->groupIds = groupIds;
        mesh->groupNames = groupNames;
        mesh->numBlocks = blockNames.size();
        mesh->blockTitle = "blocks";
        mesh->blockPieceName = "block";
        if (blockNames.size() == 1)
        {
            mesh->SetExtents(bounds);
        }
   
        md->Add(mesh);

        AddVars(meshName, meshVarsNodal[meshName], AVT_NODECENT, md);
        AddVars(meshName, meshVarsZonal[meshName], AVT_ZONECENT, md);
    }

} // namespace GEOSXFF


// ****************************************************************************
//  Method: avtGEOSXFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: Kathleen Biagas 
//  Creation:   June 9, 2022
//
// ****************************************************************************

void
avtGEOSXFileFormat::FreeUpResources(void)
{
    if(parser)
    {
        delete parser;
    }
    parser = nullptr;
    GEOSXFF::FreeUpResources();
}


void
avtGEOSXFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    if(!haveReadMetaFile)
    {
        ReadMetaFile();
    }

    // want to read the first block associated with each group within each mesh
    set<string> meshNames = parser->GetMeshNames();
    for (auto meshName : meshNames)
    {
        vector<int> firstBlockPerGroup = parser->GetMeshBlockPerGroup(meshName);
        for(auto i : firstBlockPerGroup)
        {
            int idx = parser->GetDataSetIndex(meshName, i);

            if(datasets[idx] == nullptr)
                ReadDataSet(meshName, i, idx);
            if(datasets[idx] != nullptr)
            {
                GEOSXFF::ReadVars(datasets[idx], meshName);
            }
        }

        GEOSXFF::ComputeDuplicateVars(meshName);

        int idx = parser->GetDataSetIndex(meshName, 0);
        GEOSXFF::FillMetaData(datasets[idx], meshName, md,
                              parser->GetMeshGroupNames(meshName),
                              parser->GetMeshGroupIds(meshName),
                              parser->GetMeshBlockNames(meshName));
    }
}


// ****************************************************************************
//  Method: avtGEOSXFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

vtkDataSet *
avtGEOSXFileFormat::GetMesh(int domain, const char *meshname)
{
    if(!haveReadMetaFile)
    {
        ReadMetaFile(); 
    } 
    int idx = parser->GetDataSetIndex(meshname, domain);
    if(datasets[idx] == nullptr)
    {
        ReadDataSet(meshname, domain, idx);
    }

    vtkDataSet *dataset = datasets[idx];
    if(dataset->GetNumberOfPoints() == 0)
    {
        return nullptr;
    } 
    currentMeshName = meshname;
    dataset->Register(nullptr);
    return dataset;
}


// ****************************************************************************
//  Method: avtGEOSXFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

vtkDataArray *
avtGEOSXFileFormat::GetVar(int domain, const char *varname)
{
    if(currentMeshName.empty())
    {
        debug3 << "Could not retrieve Variable " << varname << ", expected Mesh to be retrieved first" << endl;
        return nullptr;
    }
    int idx = parser->GetDataSetIndex(currentMeshName, domain);
    if(datasets[idx] == nullptr)
    {
        ReadDataSet(currentMeshName, domain, idx);
    }

    vtkDataSet *dataset = datasets[idx];
    vtkDataArray *rv = nullptr;
    string realVar(varname);

    size_t pos = realVar.find(currentMeshName);
    realVar.erase(pos, currentMeshName.length()+1);

    int vcenter = 0; // 0 = unknown, 1 = nodal, 2 = zonal;
    pos = realVar.find("_nodal");
    if (pos != string::npos)
    {
        vcenter = 1;
        realVar.erase(pos, 6);
    }
    else
    {
        pos = realVar.find("_zonal");
        if (pos != string::npos)
        {
            vcenter = 2;
            realVar.erase(pos, 6);
        }
    }
    
  
    if (vcenter == 0 || vcenter == 1) 
    {
        rv = dataset->GetPointData()->GetArray(realVar.c_str());
    }
    if (rv == nullptr && (vcenter == 0 || vcenter == 2))
    {
        rv = dataset->GetCellData()->GetArray(realVar.c_str());
    }
    if (rv == nullptr)
    {
        debug3 << "Could not find Variable: " << realVar << endl;
    }
    else
    {
        rv->Register(nullptr);
    }
    return rv;
}


// ****************************************************************************
//  Method: avtGEOSXFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: biagas2 -- generated by xml2avt
//  Creation:   Thu Feb 10 14:59:09 PST 2022
//
// ****************************************************************************

vtkDataArray *
avtGEOSXFileFormat::GetVectorVar(int domain, const char *varname)
{
    //
    // There is no difference between vectors and scalars for this class.
    //
    return GetVar(domain, varname);
}

